'''
===================================================================================================
Copyright (C) 2023 Steven Linfield

This file is part of the electrochemistry-simulations package. This package is free software: you 
can redistribute it and/or modify it under the terms of the GNU General Public License as published 
by the Free Software Foundation, either version 3 of the License, or (at your option) any later 
version. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details. You should have received a copy of the GNU General 
Public License along with electrochemistry-simulations. If not, see https://www.gnu.org/licenses/
===================================================================================================

Package title:      electrochemistry-simulations
Repository:         https://github.com/MoonshinetheP/electrochemistry-simulations
Date of creation:   09/03/2023
Main author:        Steven Linfield (MoonshinetheP)
Collaborators:      None
Acknowledgements:   Oliver Rodriguez (oliverrdz)
    
Filename:           plot.py

===================================================================================================
How to use this file:
    

===================================================================================================
'''




import os
from errno import EEXIST
import time

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


class Plotter:
    '''Plots potential waveforms and analysed oscilloscope data generated from other files in the package\n
    
    Requires:\n
    shape - an instance of one of the potential waveform classes from the waveforms.py file \n
    analysis - an instance of Oscilloscope class generated using the operations.py file \n
    display - a True or False option for whether the plot is displayed \n
    save - a True or false option for whether the plot is saved as a .png image'''

    def __init__(self, shape, analysis, display = True, animate = True, save = True):

        '''PARAMETER INITIALISATION'''
        self.shape = shape      # potential waveform object generated by waveforms.py
        self.analysis = analysis        # analysed oscilloscope data object generated using operations.py
        self.display = display      # boolean value which decides if the plot is displayed or not
        self.animate = animate
        self.save = save        # boolean value which decides if the plot is saved or not

        '''PLOT DEFINITION'''
        fig, (ax1, ax2) = plt.subplots(1,2, figsize=(12, 5))        # defines a matplotlib figure with two horizontally arranged subplots
        left, = ax1.plot(self.shape.tWF, self.shape.EWF, linewidth = 1, linestyle = '-', color = 'blue', marker = None, label = None, visible = True)       # plots the potential waveform from waveforms.py on the left-hand subplot
        right, = ax2.plot(self.analysis.E[1:], self.analysis.i, linewidth = 1, linestyle = '-', color = 'red', marker = None, label = None, visible = True)     # plots the oscilloscope data from operations.py on the right-hand subplot
        
        '''PLOT SETTINGS'''
        ax1.set_xlim(np.amin(self.shape.tWF) - (0.1 * (np.amax(self.shape.tWF) - np.amin(self.shape.tWF))), np.amax(self.shape.tWF) + (0.1 * (np.amax(self.shape.tWF) - np.amin(self.shape.tWF))))      # sets the x-axis limits of the left-hand subplot to +/- 10% of the waveform's time range
        ax1.set_ylim(np.amin(self.shape.EWF) - (0.1 * (np.amax(self.shape.EWF) - np.amin(self.shape.EWF))), np.amax(self.shape.EWF) + (0.1 * (np.amax(self.shape.EWF) - np.amin(self.shape.EWF))))      # sets the y-axis limits of the left-hand subplot to +/- 10% of the waveform's potential range
        ax1.set_title('E vs. t', pad = 15, fontsize = 20)       # defines the title and settings of the left-hand subplot
        ax1.set_xlabel('t / s', labelpad = 5, fontsize = 15)        # defines the x-axis label and settings of the left-hand subplot
        ax1.set_ylabel('E / V', labelpad = 5, fontsize = 15)        # defines the y-axis labe and settings of the left-hand subplot

        ax2.set_xlim(np.amin(self.analysis.E) - (0.1 * (np.amax(self.analysis.E) - np.amin(self.analysis.E))), np.amax(self.analysis.E) + (0.1 * (np.amax(self.analysis.E) - np.amin(self.analysis.E))))        # sets the x-axis of the right-hand subplot to +/- 10% of the oscilloscope data's potential range
        ax2.set_ylim(np.nanmin(self.analysis.i) - (0.1 * (np.nanmax(self.analysis.i) - np.nanmin(self.analysis.i))), np.nanmax(self.analysis.i) + (0.1 * (np.nanmax(self.analysis.i) - np.nanmin(self.analysis.i))))        # sets the y-axis of the right-hand subplot to +/- 10% of the oscilloscope data's current range
        ax2.set_title('i vs. E', pad = 15, fontsize = 20)       # defines the title and settings of the right-hand subplot
        ax2.set_xlabel('E / V', labelpad = 5, fontsize = 15)        # defines the x-axis label and settings of the right-hand subplot 
        ax2.set_ylabel('i / A', labelpad = 5, fontsize = 15)        # defines the y-axis label and settings of the right-hand subplot

        '''PLOT GENERATION & MANAGEMENT '''
        if self.save == True:
            plt.savefig(f'{os.getcwd()}/plots/{time.strftime("%Y-%m-%d %H-%M-%S")} {analysis.data.label} {shape.label} data with {analysis.method}.png')      # saves the figure as a .png image
        
        if self.display == True and self.animate == False:
            plt.show()      # displays the figure

        if self.animate == True:
        
            '''ANIMATION FUNCTIONS'''
            def potential(i):
                left.set_data(shape.tWF[:i], shape.EWF[:i])
                return left, 

            def current(i):
                right.set_data(analysis.EPLOT[:i], analysis.i[:i])
                return right,


            '''ANIMATION'''
            Evt = animation.FuncAnimation(fig, potential, frames = shape.indexWF.size, interval = 4, repeat = False, blit = True) 
            ivE = animation.FuncAnimation(fig, current, frames = analysis.EPLOT.size, interval = 10, repeat = False, blit = True)
            plt.show()

        '''PLOT CLOSURE'''
        plt.close()     # closes the figure